// Professional Board Performance Manager - Система управления производительностью
// Оптимизация Canvas операций и мониторинг FPS

class PerformanceManager {
    constructor(board) {
        this.board = board;
        this.isEnabled = true;
        
        // Метрики производительности
        this.metrics = {
            fps: 0,
            frameTime: 0,
            renderTime: 0,
            objectCount: 0,
            pointCount: 0,
            lastFrameTime: performance.now(),
            frameCount: 0,
            samples: []
        };
        
        // Настройки оптимизации
        this.settings = {
            maxFPS: 60,
            targetFrameTime: 16.67, // 60 FPS
            throttleThreshold: 30, // FPS ниже которого включается throttling
            maxRenderObjects: 1000,
            maxPointsPerStroke: 500,
            cullingEnabled: true,
            levelOfDetail: true,
            adaptiveQuality: true
        };
        
        // Система throttling
        this.throttle = {
            enabled: false,
            level: 0, // 0-3 уровни throttling
            lastRenderTime: 0,
            renderInterval: 16.67 // мс между рендерами
        };
        
        // Система Dirty Rectangles для оптимизации перерисовки
        this.dirtyRegions = [];
        this.fullRedrawRequired = true;
        
        // Буферизация и кэширование
        this.cache = {
            offscreenCanvas: null,
            staticLayer: null,
            dynamicLayer: null,
            gridCache: null
        };
        
        this.init();
    }
    
    init() {
        // Создание offscreen canvas для кэширования
        this.createOffscreenBuffers();
        
        // Запуск мониторинга производительности
        this.startPerformanceMonitoring();
        
        // Настройка событий оптимизации
        this.setupOptimizationEvents();
        
        console.log('✅ PerformanceManager инициализирован');
    }
    
    createOffscreenBuffers() {
        try {
            const canvas = this.board.canvas;
            
            // Основной offscreen buffer
            this.cache.offscreenCanvas = document.createElement('canvas');
            this.cache.offscreenCanvas.width = canvas.width;
            this.cache.offscreenCanvas.height = canvas.height;
            this.cache.offscreenCtx = this.cache.offscreenCanvas.getContext('2d', {
                alpha: true,
                desynchronized: true
            });
            
            // Статический слой (сетка, фон)
            this.cache.staticLayer = document.createElement('canvas');
            this.cache.staticLayer.width = canvas.width;
            this.cache.staticLayer.height = canvas.height;
            this.cache.staticCtx = this.cache.staticLayer.getContext('2d');
            
            // Динамический слой (объекты рисования)
            this.cache.dynamicLayer = document.createElement('canvas');
            this.cache.dynamicLayer.width = canvas.width;
            this.cache.dynamicLayer.height = canvas.height;
            this.cache.dynamicCtx = this.cache.dynamicLayer.getContext('2d');
            
            console.log('✅ Offscreen буферы созданы');
        } catch (error) {
            console.error('❌ Ошибка создания offscreen буферов:', error);
        }
    }
    
    startPerformanceMonitoring() {
        // Мониторинг FPS
        const updateMetrics = () => {
            const now = performance.now();
            const frameTime = now - this.metrics.lastFrameTime;
            
            this.metrics.frameTime = frameTime;
            this.metrics.frameCount++;
            
            // Вычисление FPS каждую секунду
            if (this.metrics.frameCount % 60 === 0) {
                this.metrics.fps = Math.round(1000 / frameTime);
                this.updateThrottling();
                this.updateAdaptiveQuality();
            }
            
            this.metrics.lastFrameTime = now;
            
            if (this.isEnabled) {
                requestAnimationFrame(updateMetrics);
            }
        };
        
        requestAnimationFrame(updateMetrics);
    }
    
    setupOptimizationEvents() {
        // Обработка изменения размера canvas
        this.board.on('resize', () => {
            this.resizeBuffers();
        });
        
        // Обработка добавления объектов
        this.board.on('objectAdded', (object) => {
            this.updateObjectMetrics();
            this.markRegionDirty(object);
        });
        
        // Обработка изменения объектов
        this.board.on('objectModified', (object) => {
            this.markRegionDirty(object);
        });
        
        // Обработка удаления объектов
        this.board.on('objectRemoved', (object) => {
            this.updateObjectMetrics();
            this.markRegionDirty(object);
        });
    }
    
    updateThrottling() {
        const fps = this.metrics.fps;
        
        if (fps < this.settings.throttleThreshold) {
            // Включаем throttling
            this.throttle.enabled = true;
            
            if (fps < 15) {
                this.throttle.level = 3; // Максимальный throttling
                this.throttle.renderInterval = 100; // 10 FPS
            } else if (fps < 20) {
                this.throttle.level = 2;
                this.throttle.renderInterval = 66.67; // 15 FPS
            } else if (fps < 25) {
                this.throttle.level = 1;
                this.throttle.renderInterval = 40; // 25 FPS
            } else {
                this.throttle.level = 0;
                this.throttle.renderInterval = 33.33; // 30 FPS
            }
        } else {
            // Отключаем throttling
            this.throttle.enabled = false;
            this.throttle.level = 0;
            this.throttle.renderInterval = 16.67; // 60 FPS
        }
    }
    
    updateAdaptiveQuality() {
        if (!this.settings.adaptiveQuality) return;
        
        const fps = this.metrics.fps;
        
        // Адаптивное качество рендеринга
        if (fps < 20) {
            // Низкое качество для производительности
            this.board.config.antialiasing = false;
            this.settings.levelOfDetail = true;
            this.settings.maxPointsPerStroke = 200;
        } else if (fps < 40) {
            // Среднее качество
            this.board.config.antialiasing = true;
            this.settings.levelOfDetail = true;
            this.settings.maxPointsPerStroke = 350;
        } else {
            // Высокое качество
            this.board.config.antialiasing = true;
            this.settings.levelOfDetail = false;
            this.settings.maxPointsPerStroke = 500;
        }
        
        // Обновление контекста Canvas
        if (this.board.ctx) {
            this.board.ctx.imageSmoothingEnabled = this.board.config.antialiasing;
        }
    }
    
    shouldRender() {
        if (!this.throttle.enabled) return true;
        
        const now = performance.now();
        return (now - this.throttle.lastRenderTime) >= this.throttle.renderInterval;
    }
    
    beforeRender() {
        this.metrics.renderStartTime = performance.now();
        
        if (this.throttle.enabled) {
            this.throttle.lastRenderTime = this.metrics.renderStartTime;
        }
    }
    
    afterRender() {
        this.metrics.renderTime = performance.now() - this.metrics.renderStartTime;
        this.fullRedrawRequired = false;
        this.dirtyRegions = [];
    }
    
    optimizeStroke(stroke) {
        if (!this.settings.levelOfDetail || !stroke.points) return stroke;
        
        // Упрощение точек для повышения производительности
        if (stroke.points.length > this.settings.maxPointsPerStroke) {
            stroke.points = this.simplifyPoints(stroke.points, this.settings.maxPointsPerStroke);
        }
        
        return stroke;
    }
    
    simplifyPoints(points, maxPoints) {
        if (points.length <= maxPoints) return points;
        
        // Алгоритм Douglas-Peucker для упрощения линии
        const epsilon = this.calculateEpsilon(points, maxPoints);
        return this.douglasPeucker(points, epsilon);
    }
    
    calculateEpsilon(points, targetCount) {
        // Адаптивное вычисление epsilon на основе количества точек
        const ratio = points.length / targetCount;
        return Math.max(0.5, Math.min(5, ratio * 0.5));
    }
    
    douglasPeucker(points, epsilon) {
        if (points.length <= 2) return points;
        
        // Найти точку с максимальным расстоянием
        let maxDistance = 0;
        let maxIndex = 0;
        
        for (let i = 1; i < points.length - 1; i++) {
            const distance = this.perpendicularDistance(
                points[i],
                points[0],
                points[points.length - 1]
            );
            
            if (distance > maxDistance) {
                maxDistance = distance;
                maxIndex = i;
            }
        }
        
        // Рекурсивное упрощение
        if (maxDistance > epsilon) {
            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), epsilon);
            const right = this.douglasPeucker(points.slice(maxIndex), epsilon);
            
            return left.slice(0, -1).concat(right);
        } else {
            return [points[0], points[points.length - 1]];
        }
    }
    
    perpendicularDistance(point, lineStart, lineEnd) {
        const dx = lineEnd.x - lineStart.x;
        const dy = lineEnd.y - lineStart.y;
        
        if (dx === 0 && dy === 0) {
            return Math.sqrt(
                Math.pow(point.x - lineStart.x, 2) +
                Math.pow(point.y - lineStart.y, 2)
            );
        }
        
        const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) /
                  (dx * dx + dy * dy);
        
        const closestPoint = {
            x: lineStart.x + t * dx,
            y: lineStart.y + t * dy
        };
        
        return Math.sqrt(
            Math.pow(point.x - closestPoint.x, 2) +
            Math.pow(point.y - closestPoint.y, 2)
        );
    }
    
    markRegionDirty(object) {
        if (!object) {
            this.fullRedrawRequired = true;
            return;
        }
        
        const bounds = this.getObjectBounds(object);
        
        // Добавляем отступы для кисти
        const padding = (object.brushSize || 10) + 5;
        
        this.dirtyRegions.push({
            x: bounds.x - padding,
            y: bounds.y - padding,
            width: bounds.width + padding * 2,
            height: bounds.height + padding * 2
        });
    }
    
    getObjectBounds(object) {
        switch (object.type) {
            case 'stroke':
                if (!object.points || object.points.length === 0) {
                    return { x: 0, y: 0, width: 0, height: 0 };
                }
                
                let minX = object.points[0].x;
                let minY = object.points[0].y;
                let maxX = object.points[0].x;
                let maxY = object.points[0].y;
                
                object.points.forEach(point => {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
                
            case 'shape':
                return {
                    x: object.x || 0,
                    y: object.y || 0,
                    width: object.width || 0,
                    height: object.height || 0
                };
                
            default:
                return {
                    x: object.x || 0,
                    y: object.y || 0,
                    width: object.width || 100,
                    height: object.height || 50
                };
        }
    }
    
    isObjectVisible(object) {
        if (!this.settings.cullingEnabled) return true;
        
        const bounds = this.getObjectBounds(object);
        const viewport = this.getViewportBounds();
        
        // Проверка пересечения с viewport
        return !(bounds.x > viewport.x + viewport.width ||
                bounds.x + bounds.width < viewport.x ||
                bounds.y > viewport.y + viewport.height ||
                bounds.y + bounds.height < viewport.y);
    }
    
    getViewportBounds() {
        const state = this.board.state;
        return {
            x: -state.panX / state.zoom,
            y: -state.panY / state.zoom,
            width: this.board.canvas.width / state.zoom,
            height: this.board.canvas.height / state.zoom
        };
    }
    
    updateObjectMetrics() {
        this.metrics.objectCount = this.board.objects.size;
        
        let totalPoints = 0;
        this.board.objects.forEach(object => {
            if (object.type === 'stroke' && object.points) {
                totalPoints += object.points.length;
            }
        });
        this.metrics.pointCount = totalPoints;
    }
    
    resizeBuffers() {
        const canvas = this.board.canvas;
        
        // Изменение размера всех буферов
        [this.cache.offscreenCanvas, this.cache.staticLayer, this.cache.dynamicLayer].forEach(buffer => {
            if (buffer) {
                buffer.width = canvas.width;
                buffer.height = canvas.height;
            }
        });
        
        this.fullRedrawRequired = true;
    }
    
    // Публичный API для мониторинга
    getMetrics() {
        return {
            ...this.metrics,
            throttleLevel: this.throttle.level,
            throttleEnabled: this.throttle.enabled
        };
    }
    
    // Публичный API для настройки
    updateSettings(newSettings) {
        Object.assign(this.settings, newSettings);
    }
    
    // Очистка ресурсов
    destroy() {
        this.isEnabled = false;
        
        // Очистка буферов
        Object.values(this.cache).forEach(buffer => {
            if (buffer && buffer.width) {
                buffer.width = 0;
                buffer.height = 0;
            }
        });
        
        this.cache = {};
        this.dirtyRegions = [];
        
        console.log('PerformanceManager уничтожен');
    }
}

// Система управления памятью для предотвращения утечек
class MemoryManager {
    constructor() {
        this.trackedObjects = new WeakMap();
        this.pools = {
            points: [],
            strokes: [],
            shapes: []
        };
        this.maxPoolSize = 100;
    }
    
    // Пул объектов для переиспользования
    getFromPool(type) {
        const pool = this.pools[type];
        return pool.length > 0 ? pool.pop() : null;
    }
    
    returnToPool(type, object) {
        const pool = this.pools[type];
        if (pool.length < this.maxPoolSize) {
            // Очистка объекта перед возвратом в пул
            this.cleanObject(object);
            pool.push(object);
        }
    }
    
    cleanObject(object) {
        // Очистка ссылок для предотвращения утечек памяти
        if (object.points) {
            object.points.length = 0;
        }
        if (object.element) {
            object.element = null;
        }
        if (object.listeners) {
            object.listeners.clear();
        }
    }
    
    // Принудительная очистка памяти
    forceCleanup() {
        // Очистка пулов
        Object.values(this.pools).forEach(pool => {
            pool.length = 0;
        });
        
        // Принудительная сборка мусора (если поддерживается)
        if (window.gc) {
            window.gc();
        }
    }
}

// Экспорт классов
window.PerformanceManager = PerformanceManager;
window.MemoryManager = MemoryManager;
